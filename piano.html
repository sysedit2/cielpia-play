<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PianoBar</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .animate-pulse {
      animation: pulse 0.6s ease-in-out;
    }
  </style>
</head>
<body class="min-h-screen bg-gray-50 p-4">
  <div id="root"></div>

  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useCallback, useRef } = React;

    const TRANSLATIONS = {
      "ko-KR": {
        "appTitle": "피아노바",
        "songInputPlaceholder": "노래를 요청하세요...",
        "parseSongButton": "노래 분석",
        "processingButton": "처리 중...",
        "playingPrefix": "재생 중: ",
        "readyToPlayPrefix": "재생 준비: ",
        "playButton": "재생",
        "stopButton": "정지",
        "parseErrorMessage": "죄송합니다, 노래를 분석하는 데 문제가 있었습니다. 다른 요청을 시도해 주세요.",
        "happyBirthday": "생일 축하합니다",
        "twinkleTwinkle": "반짝반짝 작은 별",
        "maryHadLamb": "메리는 양을 키웠어요",
        "jingleBells": "징글벨",
        "sadMelody": "슬픈 멜로디",
        "amazingGrace": "어메이징 그레이스",
        "silentNight": "고요한 밤",
        "auldLangSyne": "석별의 정"
      },
      "en-US": {
        "appTitle": "PianoBar",
        "songInputPlaceholder": "Request a song...",
        "parseSongButton": "Parse song",
        "processingButton": "Processing...",
        "playingPrefix": "Playing: ",
        "readyToPlayPrefix": "Ready to play: ",
        "playButton": "Play",
        "stopButton": "Stop",
        "parseErrorMessage": "Sorry, I had trouble parsing that song. Please try a different request.",
        "happyBirthday": "Happy birthday",
        "twinkleTwinkle": "Twinkle twinkle little star",
        "maryHadLamb": "Mary had a little lamb",
        "jingleBells": "Jingle bells",
        "sadMelody": "Sad melody",
        "amazingGrace": "Amazing grace",
        "silentNight": "Silent night",
        "auldLangSyne": "Auld lang syne"
      }
    };

    const browserLocale = navigator.language || 'ko-KR';
    const locale = TRANSLATIONS[browserLocale] ? browserLocale : 'ko-KR';
    const t = (key) => TRANSLATIONS[locale]?.[key] || TRANSLATIONS['en-US'][key] || key;

    const PianoPlayer = () => {
      const [activeKeys, setActiveKeys] = useState(new Set());
      const [keyAnimations, setKeyAnimations] = useState(new Map());
      const [songInput, setSongInput] = useState('');
      const [isProcessing, setIsProcessing] = useState(false);
      const [currentSong, setCurrentSong] = useState(null);
      const [isPlaying, setIsPlaying] = useState(false);
      const [playbackSpeed, setPlaybackSpeed] = useState(1.25);
      const [isInputFocused, setIsInputFocused] = useState(false);
      const audioContextRef = useRef(null);
      const sequenceRef = useRef(null);

      const noteFrequencies = {
        'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13, 'E4': 329.63,
        'F4': 349.23, 'F#4': 369.99, 'G4': 392.00, 'G#4': 415.30, 'A4': 440.00,
        'A#4': 466.16, 'B4': 493.88, 'C5': 523.25, 'C#5': 554.37, 'D5': 587.33,
        'D#5': 622.25, 'E5': 659.25, 'F5': 698.46, 'F#5': 739.99, 'G5': 783.99
      };

      const keyMappings = {
        'a': 'C4', 'w': 'C#4', 's': 'D4', 'e': 'D#4', 'd': 'E4',
        'f': 'F4', 't': 'F#4', 'g': 'G4', 'y': 'G#4', 'h': 'A4', 
        'u': 'A#4', 'j': 'B4', 'k': 'C5', 'o': 'C#5', 'l': 'D5',
        'p': 'D#5', ';': 'E5', "'": 'F5'
      };

      const pianoKeys = [
        { note: 'C4', type: 'white', key: 'a' },
        { note: 'C#4', type: 'black', key: 'w' },
        { note: 'D4', type: 'white', key: 's' },
        { note: 'D#4', type: 'black', key: 'e' },
        { note: 'E4', type: 'white', key: 'd' },
        { note: 'F4', type: 'white', key: 'f' },
        { note: 'F#4', type: 'black', key: 't' },
        { note: 'G4', type: 'white', key: 'g' },
        { note: 'G#4', type: 'black', key: 'y' },
        { note: 'A4', type: 'white', key: 'h' },
        { note: 'A#4', type: 'black', key: 'u' },
        { note: 'B4', type: 'white', key: 'j' },
        { note: 'C5', type: 'white', key: 'k' },
        { note: 'C#5', type: 'black', key: 'o' },
        { note: 'D5', type: 'white', key: 'l' },
        { note: 'D#5', type: 'black', key: 'p' },
        { note: 'E5', type: 'white', key: ';' },
        { note: 'F5', type: 'white', key: "'" }
      ];

      useEffect(() => {
        const initAudio = () => {
          try {
            audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
          } catch (error) {
            console.error('Failed to initialize Web Audio API:', error);
          }
        };

        const handleFirstInteraction = () => {
          initAudio();
          if (audioContextRef.current && audioContextRef.current.state === 'suspended') {
            audioContextRef.current.resume();
          }
          document.removeEventListener('click', handleFirstInteraction);
          document.removeEventListener('keydown', handleFirstInteraction);
        };

        document.addEventListener('click', handleFirstInteraction);
        document.addEventListener('keydown', handleFirstInteraction);

        return () => {
          document.removeEventListener('click', handleFirstInteraction);
          document.removeEventListener('keydown', handleFirstInteraction);
          if (audioContextRef.current) {
            audioContextRef.current.close();
          }
        };
      }, []);

      const playTone = (frequency, duration = 0.5) => {
        if (!audioContextRef.current) return;

        const context = audioContextRef.current;
        const oscillator = context.createOscillator();
        const gainNode = context.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(context.destination);

        oscillator.frequency.setValueAtTime(frequency, context.currentTime);
        oscillator.type = 'triangle';

        gainNode.gain.setValueAtTime(0, context.currentTime);
        gainNode.gain.linearRampToValueAtTime(0.3, context.currentTime + 0.02);
        gainNode.gain.linearRampToValueAtTime(0.2, context.currentTime + duration * 0.1);
        gainNode.gain.linearRampToValueAtTime(0.15, context.currentTime + duration * 0.8);
        gainNode.gain.exponentialRampToValueAtTime(0.001, context.currentTime + duration);

        oscillator.start(context.currentTime);
        oscillator.stop(context.currentTime + duration);
      };

      const playNote = useCallback((note) => {
        const frequency = noteFrequencies[note];
        if (frequency) {
          playTone(frequency, 0.8);
          
          const noteKey = `${note}-${Date.now()}`;
          setActiveKeys(prev => new Set([...prev, noteKey]));
          setKeyAnimations(prev => new Map(prev.set(note, Date.now())));
          
          setTimeout(() => {
            setActiveKeys(prev => {
              const newSet = new Set(prev);
              newSet.delete(noteKey);
              return newSet;
            });
          }, 300);
        }
      }, []);

      useEffect(() => {
        const handleKeyDown = (e) => {
          if (isInputFocused) return;
          
          const note = keyMappings[e.key.toLowerCase()];
          if (note && !activeKeys.has(note)) {
            playNote(note);
          }
        };

        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [playNote, activeKeys, isInputFocused]);

      const parseSong = async (songText) => {
        setIsProcessing(true);
        try {
          const response = await fetch("https://api.anthropic.com/v1/messages", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              model: "claude-sonnet-4-20250514",
              max_tokens: 1000,
              messages: [
                { 
                  role: "user", 
                  content: `Parse this song request and convert it to a COMPLETE melody using only these available piano notes: C4, C#4, D4, D#4, E4, F4, F#4, G4, G#4, A4, A#4, B4, C5, C#5, D5, D#5, E5, F5, F#5, G5.

Song request: "${songText}"

Please respond with ONLY a JSON object in this exact format:
{
  "title": "Song Name",
  "notes": [
    {"note": "C4", "duration": 0.5, "time": 0},
    {"note": "D4", "duration": 0.5, "time": 0.5},
    {"note": "E4", "duration": 1, "time": 1}
  ]
}

IMPORTANT: Create the COMPLETE song with ALL verses and sections. Use 25-40 notes for popular songs to capture the full melody. Use duration in seconds (0.25, 0.5, 1, 2) and time as the start time in seconds.

DO NOT OUTPUT ANYTHING OTHER THAN VALID JSON.` 
                }
              ],
            })
          });

          const data = await response.json();
          const text = data.content.map(i => i.text || "").join("\n");
          const clean = text.replace(/```json|```/g, "").trim();
          const songData = JSON.parse(clean);
          
          setCurrentSong(songData);
          
          setTimeout(() => {
            if (audioContextRef.current) {
              playParsedSong(songData);
            }
          }, 100);
          
          return songData;
        } catch (error) {
          console.error('Error parsing song:', error);
          alert(t('parseErrorMessage'));
          return null;
        } finally {
          setIsProcessing(false);
        }
      };

      const playParsedSong = (songData) => {
        if (!songData || !audioContextRef.current) return;

        setIsPlaying(true);
        
        if (sequenceRef.current) {
          sequenceRef.current.forEach(clearTimeout);
        }

        const adjustedNotes = songData.notes.map(note => ({
          ...note,
          time: note.time / playbackSpeed,
          duration: note.duration / playbackSpeed
        }));

        let noteTimeouts = [];
        
        adjustedNotes.forEach((note, index) => {
          const timeout = setTimeout(() => {
            const frequency = noteFrequencies[note.note];
            if (frequency) {
              playTone(frequency, note.duration);
            }
            
            const noteKey = `${note.note}-${index}-${Date.now()}`;
            setActiveKeys(prev => new Set([...prev, noteKey]));
            setKeyAnimations(prev => new Map(prev.set(note.note, Date.now())));
            
            setTimeout(() => {
              setActiveKeys(prev => {
                const newSet = new Set(prev);
                newSet.delete(noteKey);
                return newSet;
              });
            }, note.duration * 1000);
          }, note.time * 1000);
          
          noteTimeouts.push(timeout);
        });

        sequenceRef.current = noteTimeouts;

        const totalDuration = Math.max(...adjustedNotes.map(n => n.time + n.duration));
        
        const completionTimeout = setTimeout(() => {
          setIsPlaying(false);
          setActiveKeys(new Set());
        }, (totalDuration + 0.5) * 1000);
        
        noteTimeouts.push(completionTimeout);
      };

      const playSong = () => {
        if (!currentSong) return;
        playParsedSong(currentSong);
      };

      const stopSong = () => {
        setIsPlaying(false);
        if (sequenceRef.current) {
          sequenceRef.current.forEach(clearTimeout);
        }
        setActiveKeys(new Set());
      };

      const handleSongSubmit = async (e) => {
        e.preventDefault();
        if (!songInput.trim()) return;
        
        const songData = await parseSong(songInput);
        if (songData) {
          setSongInput('');
        }
      };

      return (
        <div className="max-w-6xl mx-auto">
          <h1 className="text-4xl font-bold text-gray-800 text-center mb-8 mt-12">{t('appTitle')}</h1>
          
          <div className="flex justify-center px-8 mb-8">
            <div className="bg-white rounded-lg shadow-sm p-4" style={{width: '736px'}}>
              <div className="flex gap-3 items-center">
                <input
                  type="text"
                  value={songInput}
                  onChange={(e) => setSongInput(e.target.value)}
                  onKeyDown={(e) => e.key === 'Enter' && handleSongSubmit(e)}
                  onFocus={() => setIsInputFocused(true)}
                  onBlur={() => setIsInputFocused(false)}
                  placeholder={t('songInputPlaceholder')}
                  className="flex-1 px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-gray-400 focus:border-transparent outline-none text-gray-700"
                  disabled={isProcessing}
                />
                <button
                  onClick={handleSongSubmit}
                  disabled={isProcessing || !songInput.trim()}
                  className="px-4 py-2 bg-gray-700 text-white rounded hover:bg-gray-800 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors whitespace-nowrap"
                >
                  {isProcessing ? t('processingButton') : t('parseSongButton')}
                </button>
              </div>

              {currentSong && (
                <div className="mt-4 pt-4 border-t border-gray-200">
                  <div className="flex items-center justify-between">
                    <h3 className="text-lg font-medium text-gray-700">
                      {isPlaying ? `${t('playingPrefix')}${currentSong.title}` : `${t('readyToPlayPrefix')}${currentSong.title}`}
                    </h3>
                    <div className="flex gap-2">
                      {!isPlaying ? (
                        <button
                          onClick={playSong}
                          className="px-3 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors flex items-center gap-1"
                        >
                          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M8 5v14l11-7z"/>
                          </svg>
                          {t('playButton')}
                        </button>
                      ) : (
                        <button
                          onClick={stopSong}
                          className="px-3 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors flex items-center gap-1"
                        >
                          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                            <rect x="6" y="4" width="4" height="16"/>
                            <rect x="14" y="4" width="4" height="16"/>
                          </svg>
                          {t('stopButton')}
                        </button>
                      )}
                    </div>
                  </div>
                </div>
              )}
            </div>
          </div>

          <div className="flex justify-center px-8 mb-8">
            <div className="relative bg-gray-200 p-4 rounded-2xl shadow-sm" style={{width: '736px'}}>
              <div className="relative">
                <div className="flex">
                  {pianoKeys.filter(key => key.type === 'white').map((key) => {
                    const isActive = Array.from(activeKeys).some(activeKey => activeKey.startsWith(key.note));
                    const animationKey = keyAnimations.get(key.note) || 0;
                    
                    return (
                      <button
                        key={key.note}
                        onMouseDown={() => playNote(key.note)}
                        className={`w-16 h-64 border border-gray-300 rounded-b-xl hover:bg-gray-50 active:bg-gray-100 transition-all duration-300 flex flex-col justify-end items-center pb-4 ${isActive ? 'bg-blue-200 border-blue-400 animate-pulse' : 'bg-white'}`}
                        style={{
                          animationDuration: '0.6s',
                          animationIterationCount: '1',
                          animationKey: animationKey
                        }}
                      >
                        <span className="text-sm text-gray-800 font-bold mb-1">
                          {key.key?.toUpperCase()}
                        </span>
                        <span className="text-xs text-gray-600 opacity-80">{key.note}</span>
                      </button>
                    );
                  })}
                </div>

                <div className="absolute top-0 left-0 flex">
                  {pianoKeys.filter(key => key.type === 'black').map((key) => {
                    const whiteKeyIndex = pianoKeys.filter(k => k.type === 'white' && 
                      pianoKeys.indexOf(k) < pianoKeys.indexOf(key)).length;
                    
                    const leftOffset = (whiteKeyIndex * 64) - 24;
                    const isActive = Array.from(activeKeys).some(activeKey => activeKey.startsWith(key.note));
                    const animationKey = keyAnimations.get(key.note) || 0;
                    
                    return (
                      <button
                        key={key.note}
                        onMouseDown={() => playNote(key.note)}
                        style={{ left: `${leftOffset + 4}px`, animationKey: animationKey }}
                        className={`absolute w-12 h-40 bg-black border border-gray-800 rounded-b-lg shadow-2xl text-white hover:bg-gray-800 active:bg-gray-700 transition-all duration-300 flex flex-col justify-end items-center pb-4 z-10 ${isActive ? 'bg-blue-600 border-blue-500 animate-pulse' : ''}`}
                      >
                        <span className="text-xs font-bold bg-black bg-opacity-50 px-1 py-0.5 rounded text-white mb-1">
                          {key.key?.toUpperCase()}
                        </span>
                        <span className="text-xs opacity-75">{key.note}</span>
                      </button>
                    );
                  })}
                </div>
              </div>
            </div>
          </div>

          <div className="flex justify-center px-8">
            <div style={{width: '736px'}}>
              <div className="flex flex-wrap gap-2 justify-center">
                {[
                  { key: 'happyBirthday', value: locale === 'ko-KR' ? '생일 축하합니다' : 'Happy birthday' },
                  { key: 'twinkleTwinkle', value: locale === 'ko-KR' ? '반짝반짝 작은 별' : 'Twinkle twinkle little star' },
                  { key: 'maryHadLamb', value: locale === 'ko-KR' ? '메리는 양을 키웠어요' : 'Mary had a little lamb' },
                  { key: 'jingleBells', value: locale === 'ko-KR' ? '징글벨' : 'Jingle bells' },
                  { key: 'sadMelody', value: locale === 'ko-KR' ? '슬픈 멜로디' : 'Sad melody' },
                  { key: 'amazingGrace', value: locale === 'ko-KR' ? '어메이징 그레이스' : 'Amazing grace' },
                  { key: 'silentNight', value: locale === 'ko-KR' ? '고요한 밤' : 'Silent night' },
                  { key: 'auldLangSyne', value: locale === 'ko-KR' ? '석별의 정' : 'Auld lang syne' }
                ].map((suggestion) => (
                  <button
                    key={suggestion.key}
                    onClick={async () => {
                      setCurrentSong(null);
                      setIsPlaying(false);
                      if (sequenceRef.current) {
                        sequenceRef.current.forEach(clearTimeout);
                      }
                      setActiveKeys(new Set());
                      
                      setSongInput(suggestion.value);
                      await parseSong(suggestion.value);
                    }}
                    disabled={isProcessing}
                    className="px-3 py-1 bg-gray-100 text-gray-700 rounded-full text-sm hover:bg-gray-200 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    {t(suggestion.key)}
                  </button>
                ))}
              </div>
            </div>
          </div>
        </div>
      );
    };

    ReactDOM.render(<PianoPlayer />, document.getElementById('root'));
  </script>
</body>
</html>
